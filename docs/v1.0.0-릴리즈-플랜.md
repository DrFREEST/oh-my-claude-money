# OMCM v1.0.0 릴리즈 플랜

> **문서 버전**: 1.0.0-draft
> **작성일**: 2026-01-26
> **목표 릴리즈**: v1.0.0

---

## 1. 프로젝트 비전 및 목표

### 1.1 핵심 비전

**"OpenCode를 Claude Code의 완벽한 서브에이전트로 활용하여 Claude 토큰 사용량을 최대한 절약"**

```
┌─────────────────────────────────────────────────────────────────────┐
│              Claude Code (+ oh-my-claudecode)                       │
│                     "메인 오케스트레이터"                              │
├─────────────────────────────────────────────────────────────────────┤
│                              ↓                                      │
│              ┌────────────────────────────┐                        │
│              │   OMCM Fusion Router       │                        │
│              │ "작업 유형/사용량 기반 분배" │                        │
│              └────────────────────────────┘                        │
│                    ↓              ↓                                │
│     ┌──────────────────┐  ┌──────────────────┐                    │
│     │ Claude Agents    │  │ OpenCode Agents  │                    │
│     │ (복잡한 추론)    │  │ (탐색/연구)      │                    │
│     │                  │  │                  │                    │
│     │ • planner        │  │ • explore        │ ← 토큰 절약!       │
│     │ • critic         │  │ • researcher     │ ← 토큰 절약!       │
│     │ • executor-high  │  │ • writer         │                    │
│     └──────────────────┘  └──────────────────┘                    │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 핵심 목표

| 목표 | 설명 | 성공 지표 |
|------|------|----------|
| **토큰 절약** | Claude 토큰 사용량 30-40% 절감 | hulw 모드에서 측정 |
| **UX 무감지** | 사용자가 전환을 인지하지 못함 | 응답 품질 유지 |
| **실시간 동기화** | 세션 컨텍스트 완벽 공유 | 컨텍스트 손실 0% |
| **HUD 통합** | 통합 상태 정보 실시간 표시 | HUD 정확도 99%+ |

### 1.3 v1.0.0 릴리즈 범위 (Core)

**포함:**
- OpenCode 서브에이전트 통합 (run/serve/ACP)
- 컨텍스트 전달 시스템
- 자동 라우팅 엔진
- 사용량 기반 폴백
- 병렬 실행 지원
- 통합 HUD

**제외 (v1.1.0+):**
- 독립 omcm CLI 래퍼
- MCP 서버 통합
- 대시보드/모니터링

---

## 2. 기술 아키텍처

### 2.1 OpenCode 통합 방식

OpenCode CLI 문서 분석 결과, 세 가지 통합 방식을 모두 활용:

#### 2.1.1 방식 A: `run` 명령어 (단발성 작업)

```bash
opencode run --format json --model "openai/gpt-5.2" "프롬프트"
```

**사용 시나리오:**
- 단순 탐색/검색 작업
- 독립적인 분석 작업
- 빠른 응답이 필요한 경우

**장점:**
- 간단한 구현
- 격리된 실행
- JSON 형식 응답

**구현:**
```javascript
// src/executor/opencode-executor.mjs
export async function runOpenCode(prompt, options = {}) {
  const args = [
    'run',
    '--format', 'json',
    '--model', options.model || 'openai/gpt-5.2',
  ];

  if (options.files) {
    options.files.forEach(f => args.push('--file', f));
  }

  args.push(prompt);

  return spawn('opencode', args);
}
```

#### 2.1.2 방식 B: `serve` + `attach` (세션 유지)

```bash
# 서버 시작 (백그라운드)
opencode serve --port 4096

# 연결하여 실행
opencode run --attach http://localhost:4096 "프롬프트"
```

**사용 시나리오:**
- 연속적인 작업 (같은 컨텍스트 유지)
- MCP 서버 cold boot 회피
- 긴 세션 작업

**장점:**
- 세션 상태 유지
- MCP 서버 재사용
- 빠른 응답 (warm start)

**구현:**
```javascript
// src/orchestrator/opencode-server.mjs
let serverProcess = null;
let serverPort = 4096;

export async function ensureServer() {
  if (!serverProcess) {
    serverProcess = spawn('opencode', ['serve', '--port', serverPort], {
      detached: true,
      stdio: 'ignore'
    });
    await waitForServer(serverPort);
  }
  return `http://localhost:${serverPort}`;
}

export async function runWithServer(prompt, options = {}) {
  const serverUrl = await ensureServer();
  return spawn('opencode', [
    'run',
    '--attach', serverUrl,
    '--format', 'json',
    prompt
  ]);
}
```

#### 2.1.3 방식 C: ACP (Agent Client Protocol)

```bash
opencode acp
# stdin/stdout으로 nd-JSON 통신
```

**사용 시나리오:**
- 실시간 양방향 통신
- 복잡한 멀티턴 대화
- 세밀한 제어가 필요한 경우

**장점:**
- 가장 유연한 통합
- 실시간 스트리밍
- 세션 완전 제어

**구현:**
```javascript
// src/orchestrator/acp-client.mjs
import { spawn } from 'child_process';
import { createInterface } from 'readline';

export class ACPClient {
  constructor() {
    this.process = null;
    this.messageId = 0;
    this.pendingRequests = new Map();
  }

  async connect() {
    this.process = spawn('opencode', ['acp'], {
      stdio: ['pipe', 'pipe', 'inherit']
    });

    const rl = createInterface({ input: this.process.stdout });
    rl.on('line', (line) => {
      const msg = JSON.parse(line);
      this.handleMessage(msg);
    });
  }

  async send(prompt, options = {}) {
    const id = ++this.messageId;
    const message = {
      id,
      type: 'prompt',
      content: prompt,
      ...options
    };

    return new Promise((resolve, reject) => {
      this.pendingRequests.set(id, { resolve, reject });
      this.process.stdin.write(JSON.stringify(message) + '\n');
    });
  }

  handleMessage(msg) {
    const pending = this.pendingRequests.get(msg.id);
    if (pending) {
      pending.resolve(msg);
      this.pendingRequests.delete(msg.id);
    }
  }
}
```

### 2.2 통합 실행 전략

세 가지 방식을 상황에 따라 자동 선택:

```javascript
// src/orchestrator/execution-strategy.mjs
export function selectStrategy(task) {
  // 1. 단순 탐색 → run (빠른 응답)
  if (task.type === 'explore' || task.type === 'search') {
    return 'run';
  }

  // 2. 연속 작업 → serve+attach (컨텍스트 유지)
  if (task.requiresContext || task.isFollowUp) {
    return 'serve';
  }

  // 3. 복잡한 멀티턴 → ACP (세밀한 제어)
  if (task.isComplex || task.requiresStreaming) {
    return 'acp';
  }

  // 기본: run
  return 'run';
}
```

---

## 3. 컨텍스트 전달 시스템

### 3.1 전달 정보 구조

```javascript
// src/utils/context-builder.mjs
export function buildContext(session) {
  return {
    // 1. 현재 작업 설명/목표
    task: {
      description: session.currentTask,
      goal: session.taskGoal,
      constraints: session.constraints,
    },

    // 2. 관련 파일 내용
    files: {
      modified: getRecentModifiedFiles(10),
      referenced: getReferencedFiles(),
      content: getFileContents(), // 필요시 파일 내용 포함
    },

    // 3. TODO 목록
    todos: {
      pending: getTodosByStatus('pending'),
      inProgress: getTodosByStatus('in_progress'),
      completed: getTodosByStatus('completed'),
    },

    // 4. 최근 결정/학습 사항
    decisions: {
      recent: getRecentDecisions(5),
      learnings: getSessionLearnings(),
      patterns: getDetectedPatterns(),
    },

    // 5. 세션 메타데이터
    meta: {
      sessionId: session.id,
      startTime: session.startTime,
      claudeUsage: getClaudeUsage(),
      projectPath: session.projectPath,
    }
  };
}
```

### 3.2 컨텍스트 직렬화

```javascript
// src/utils/context-serializer.mjs
export function serializeForOpenCode(context) {
  const markdown = `
# 작업 컨텍스트

## 현재 작업
**설명**: ${context.task.description}
**목표**: ${context.task.goal}

## 관련 파일
${context.files.modified.map(f => `- ${f.path} (${f.status})`).join('\n')}

## TODO 목록
### 진행 중
${context.todos.inProgress.map(t => `- [ ] ${t.subject}`).join('\n')}

### 대기 중
${context.todos.pending.map(t => `- [ ] ${t.subject}`).join('\n')}

## 최근 결정 사항
${context.decisions.recent.map(d => `- ${d.summary}`).join('\n')}

## 세션 정보
- Claude 사용량: ${context.meta.claudeUsage}
- 프로젝트: ${context.meta.projectPath}
`;

  return markdown;
}
```

### 3.3 실시간 동기화

```javascript
// src/orchestrator/context-sync.mjs
export class ContextSynchronizer {
  constructor() {
    this.syncInterval = null;
    this.lastSync = null;
  }

  startSync(intervalMs = 5000) {
    this.syncInterval = setInterval(() => {
      this.syncToOpenCode();
    }, intervalMs);
  }

  async syncToOpenCode() {
    const context = buildContext(getCurrentSession());
    const contextPath = join(homedir(), '.omcm/sync/context.json');

    await writeFile(contextPath, JSON.stringify(context, null, 2));
    this.lastSync = Date.now();
  }

  stopSync() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }
  }
}
```

---

## 4. 자동 라우팅 엔진

### 4.1 라우팅 규칙

```javascript
// src/orchestrator/task-router.mjs
const ROUTING_RULES = {
  // OpenCode 선호 작업 (토큰 절약)
  preferOpenCode: [
    'explore',
    'explore-medium',
    'researcher',
    'researcher-low',
    'writer',
    'designer-low',
    'scientist-low',
  ],

  // Claude 필수 작업 (품질 우선)
  requireClaude: [
    'architect',
    'executor-high',
    'critic',
    'planner',
    'analyst',
  ],

  // 하이브리드 (상황에 따라)
  hybrid: [
    'executor',
    'designer',
    'scientist',
  ]
};
```

### 4.2 사용량 기반 폴백

```javascript
// src/orchestrator/usage-fallback.mjs
export function shouldFallbackToOpenCode() {
  const usage = getClaudeUsage();

  // 사용량 임계치
  const thresholds = {
    warning: 70,    // 70% - 하이브리드 작업 OpenCode로
    critical: 85,   // 85% - 대부분 OpenCode로
    emergency: 95,  // 95% - 거의 모든 작업 OpenCode로
  };

  if (usage.hourly >= thresholds.emergency) {
    return { fallback: true, level: 'emergency', openCodeRatio: 0.95 };
  }
  if (usage.hourly >= thresholds.critical) {
    return { fallback: true, level: 'critical', openCodeRatio: 0.8 };
  }
  if (usage.hourly >= thresholds.warning) {
    return { fallback: true, level: 'warning', openCodeRatio: 0.5 };
  }

  return { fallback: false, level: 'normal', openCodeRatio: 0.3 };
}
```

### 4.3 통합 라우팅 결정

```javascript
// src/orchestrator/fusion-router.mjs
export function routeTask(task, context) {
  const usage = shouldFallbackToOpenCode();
  const taskType = task.agentType || inferTaskType(task);

  // 1. Claude 필수 작업 (사용량 긴급 아니면 Claude)
  if (ROUTING_RULES.requireClaude.includes(taskType)) {
    if (usage.level === 'emergency') {
      return { target: 'opencode', reason: 'usage-emergency' };
    }
    return { target: 'claude', reason: 'task-requires-claude' };
  }

  // 2. OpenCode 선호 작업 (항상 OpenCode)
  if (ROUTING_RULES.preferOpenCode.includes(taskType)) {
    return { target: 'opencode', reason: 'task-prefers-opencode' };
  }

  // 3. 하이브리드 작업 (사용량 기반)
  if (usage.fallback) {
    return { target: 'opencode', reason: `usage-${usage.level}` };
  }

  // 4. 기본: Claude
  return { target: 'claude', reason: 'default' };
}
```

---

## 5. 병렬 실행 시스템

### 5.1 병렬 실행 조건

```javascript
// src/orchestrator/parallel-executor.mjs
export function canRunInParallel(tasks) {
  // 조건 1: 2개 이상의 독립적인 작업
  if (tasks.length < 2) return false;

  // 조건 2: 파일 충돌 없음
  const allFiles = tasks.flatMap(t => t.targetFiles || []);
  const uniqueFiles = new Set(allFiles);
  if (allFiles.length !== uniqueFiles.size) return false;

  // 조건 3: 의존성 없음
  if (tasks.some(t => t.dependsOn && t.dependsOn.length > 0)) return false;

  return true;
}
```

### 5.2 병렬 실행기

```javascript
// src/orchestrator/parallel-executor.mjs
export async function executeParallel(tasks, maxWorkers = 3) {
  const results = [];
  const pending = [...tasks];
  const running = new Map();

  while (pending.length > 0 || running.size > 0) {
    // 워커 슬롯이 있고 대기 작업이 있으면 시작
    while (running.size < maxWorkers && pending.length > 0) {
      const task = pending.shift();
      const route = routeTask(task);

      let promise;
      if (route.target === 'opencode') {
        promise = executeOnOpenCode(task);
      } else {
        promise = executeOnClaude(task);
      }

      running.set(task.id, { task, promise, startTime: Date.now() });
    }

    // 완료된 작업 처리
    const completed = await Promise.race(
      Array.from(running.values()).map(r => r.promise.then(result => ({ id: r.task.id, result })))
    );

    results.push(completed);
    running.delete(completed.id);
  }

  return results;
}
```

---

## 6. 통합 HUD 시스템

### 6.1 HUD 데이터 구조

```javascript
// src/hud/fusion-hud.mjs
export function getHUDData() {
  return {
    // Claude 사용량
    claude: {
      hourly: getClaudeUsage().hourly,
      daily: getClaudeUsage().daily,
      status: getClaudeStatus(), // 'normal' | 'warning' | 'critical'
    },

    // OpenCode 사용량
    opencode: {
      activeWorkers: getActiveOpenCodeWorkers(),
      totalTasks: getOpenCodeTaskCount(),
      savedTokens: getEstimatedSavedTokens(),
    },

    // 퓨전 상태
    fusion: {
      mode: getCurrentFusionMode(), // 'off' | 'hybrid' | 'full'
      routingStats: getRoutingStats(),
      lastSync: getLastSyncTime(),
    },

    // 세션 정보
    session: {
      duration: getSessionDuration(),
      tasksCompleted: getCompletedTaskCount(),
    }
  };
}
```

### 6.2 HUD 렌더링

```
┌─────────────────────────────────────────────────────────────────┐
│ OMCM v1.0.0 │ Fusion: HYBRID │ Session: 45m │ Tasks: 12/15     │
├─────────────────────────────────────────────────────────────────┤
│ Claude: ████████░░ 78% │ OpenCode: 3 workers │ Saved: ~2.4K tok│
└─────────────────────────────────────────────────────────────────┘
```

---

## 7. 구현 단계

### Phase 1: 기반 구축 (Week 1)

| 작업 | 설명 | 우선순위 |
|------|------|----------|
| OpenCode run 통합 | 기본 subprocess 실행 | P0 |
| 컨텍스트 빌더 | 컨텍스트 수집 및 직렬화 | P0 |
| 기본 라우터 | 작업 유형별 라우팅 | P0 |
| 단위 테스트 | 각 모듈 테스트 | P0 |

### Phase 2: 고급 기능 (Week 2)

| 작업 | 설명 | 우선순위 |
|------|------|----------|
| serve 모드 통합 | 서버 모드 + attach | P1 |
| ACP 클라이언트 | 양방향 통신 | P1 |
| 사용량 기반 폴백 | 자동 전환 로직 | P1 |
| 병렬 실행기 | 멀티 워커 실행 | P1 |

### Phase 3: 통합 및 최적화 (Week 3)

| 작업 | 설명 | 우선순위 |
|------|------|----------|
| HUD 통합 | 통합 상태 표시 | P1 |
| 실시간 동기화 | 컨텍스트 자동 동기화 | P2 |
| 성능 최적화 | 응답 시간 개선 | P2 |
| 통합 테스트 | E2E 테스트 | P0 |

### Phase 4: 릴리즈 준비 (Week 4)

| 작업 | 설명 | 우선순위 |
|------|------|----------|
| 문서화 | README, API 문서 | P1 |
| hulw 모드 테스트 | 핵심 시나리오 검증 | P0 |
| ulw 모드 테스트 | 자동 전환 검증 | P0 |
| autopilot 테스트 | 자율 실행 검증 | P1 |
| fallback 테스트 | 사용량 초과 시나리오 | P0 |

---

## 8. 테스트 시나리오

### 8.1 hulw 모드 테스트

```bash
# 시나리오 1: 기본 하이브리드 울트라워크
hulw 이 프로젝트의 TODO 파일들을 찾아서 정리해줘

# 검증 항목:
# - [ ] OpenCode explore 에이전트로 파일 검색 수행
# - [ ] 컨텍스트가 정확히 전달됨
# - [ ] 결과가 Claude로 통합됨
# - [ ] HUD에 퓨전 상태 표시
```

### 8.2 ulw 모드 테스트

```bash
# 시나리오 2: 사용량 기반 자동 전환
ulw 대규모 리팩토링 진행해줘

# 검증 항목:
# - [ ] 사용량 70% 미만: Claude 중심
# - [ ] 사용량 70-85%: 하이브리드
# - [ ] 사용량 85%+: OpenCode 중심
# - [ ] 전환 시 컨텍스트 손실 없음
```

### 8.3 autopilot 모드 테스트

```bash
# 시나리오 3: 자율 실행 + 퓨전
autopilot REST API 서버 만들어줘

# 검증 항목:
# - [ ] 계획 수립 (Claude planner)
# - [ ] 탐색 작업 (OpenCode explore)
# - [ ] 구현 작업 (라우팅에 따라)
# - [ ] 검증 (Claude critic)
```

### 8.4 fallback 시나리오 테스트

```bash
# 시나리오 4: Claude 사용량 90% 초과 상황 시뮬레이션

# 검증 항목:
# - [ ] 자동으로 OpenCode 폴백 활성화
# - [ ] 사용자에게 알림 표시
# - [ ] 작업 품질 유지
# - [ ] 사용량 감소 시 자동 복귀
```

### 8.5 HUD 동기화 테스트

```bash
# 시나리오 5: HUD 정보 정확도

# 검증 항목:
# - [ ] Claude 사용량 실시간 반영
# - [ ] OpenCode 워커 수 정확히 표시
# - [ ] 절약된 토큰 추정치 표시
# - [ ] 퓨전 모드 상태 정확히 표시
```

---

## 9. 파일 구조 계획

```
oh-my-claude-money/
├── src/
│   ├── executor/
│   │   ├── opencode-executor.mjs     # OpenCode run 실행기
│   │   ├── opencode-server.mjs       # OpenCode serve 관리
│   │   └── acp-client.mjs            # ACP 프로토콜 클라이언트
│   ├── orchestrator/
│   │   ├── fusion-router.mjs         # 퓨전 라우팅 엔진
│   │   ├── parallel-executor.mjs     # 병렬 실행기
│   │   ├── usage-fallback.mjs        # 사용량 기반 폴백
│   │   └── execution-strategy.mjs    # 실행 전략 선택
│   ├── context/
│   │   ├── context-builder.mjs       # 컨텍스트 수집
│   │   ├── context-serializer.mjs    # 컨텍스트 직렬화
│   │   └── context-sync.mjs          # 실시간 동기화
│   ├── hud/
│   │   ├── fusion-hud.mjs            # 퓨전 HUD 데이터
│   │   └── hud-renderer.mjs          # HUD 렌더링
│   └── utils/
│       ├── config.mjs                # 설정 관리
│       ├── usage.mjs                 # 사용량 추적
│       └── logger.mjs                # 로깅
├── tests/
│   ├── unit/
│   │   ├── executor.test.mjs
│   │   ├── router.test.mjs
│   │   └── context.test.mjs
│   └── e2e/
│       ├── hulw.test.mjs
│       ├── ulw.test.mjs
│       ├── autopilot.test.mjs
│       └── fallback.test.mjs
└── docs/
    ├── v1.0.0-릴리즈-플랜.md          # 이 문서
    ├── API-문서.md                    # API 레퍼런스
    └── 통합-가이드.md                  # 통합 가이드
```

---

## 10. 위험 요소 및 대응

| 위험 | 영향 | 대응 방안 |
|------|------|----------|
| OpenCode CLI 변경 | 높음 | 버전 고정, 어댑터 패턴 |
| 컨텍스트 손실 | 높음 | 체크섬 검증, 재전송 로직 |
| 응답 품질 저하 | 중간 | 품질 모니터링, 자동 재시도 |
| 성능 저하 | 중간 | 캐싱, 병렬화 최적화 |
| API 제한 | 낮음 | 폴백 체인, 레이트 리밋 |

---

## 11. 성공 지표

| 지표 | 목표 | 측정 방법 |
|------|------|----------|
| Claude 토큰 절약률 | 30-40% | hulw 모드 vs 일반 모드 비교 |
| 응답 품질 유지 | 95%+ | 사용자 만족도 조사 |
| 컨텍스트 전달 성공률 | 99%+ | 에러 로그 분석 |
| HUD 정확도 | 99%+ | 실제 값 vs 표시 값 비교 |
| 평균 응답 시간 | < 5초 | 응답 시간 측정 |

---

## 12. 다음 단계 (v1.1.0+)

- **독립 omcm CLI**: `omcm "prompt"` 형태의 래퍼
- **MCP 서버 통합**: OpenCode를 MCP 서버로 등록
- **대시보드**: 웹 기반 사용량 모니터링
- **비용 추적**: 실제 API 비용 추적
- **멀티 프로바이더**: Gemini, GPT 직접 통합

---

*이 문서는 QnA를 통해 수집된 요구사항을 기반으로 작성되었습니다.*
