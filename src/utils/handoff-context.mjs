/**
 * handoff-context.mjs - 프로바이더 전환 시 컨텍스트 파일 생성
 */

import { existsSync, readFileSync, writeFileSync, mkdirSync, readdirSync, statSync } from 'fs';
import { join, dirname } from 'path';

const HANDOFF_DIR = join(process.cwd(), '.omcm', 'handoff');

/**
 * 핸드오프 컨텍스트 생성
 */
export function createHandoffContext(options) {
  const defaultOptions = {
    fromModel: null,
    toModel: null,
    reason: null,
    currentTask: null,
    sessionSummary: null,
    todoList: null,
    cwd: null
  };

  const opts = Object.assign({}, defaultOptions, options);

  const fromModel = opts.fromModel;
  const toModel = opts.toModel;
  const reason = opts.reason;
  const currentTask = opts.currentTask;
  const sessionSummary = opts.sessionSummary;
  const todoList = opts.todoList;
  const cwd = opts.cwd;

  const handoffDir = cwd ? join(cwd, '.omcm', 'handoff') : HANDOFF_DIR;

  // 디렉토리 생성
  if (!existsSync(handoffDir)) {
    mkdirSync(handoffDir, { recursive: true });
  }

  const timestamp = new Date().toISOString();
  const filename = 'context-' + Date.now() + '.md';
  const filepath = join(handoffDir, filename);

  // 최신 컨텍스트는 context.md로도 저장
  const latestPath = join(handoffDir, 'context.md');

  // fromModel 이름 추출 (null 안전 처리)
  let fromModelName = 'Unknown';
  if (fromModel) {
    if (fromModel.name) {
      fromModelName = fromModel.name;
    } else if (fromModel.id) {
      fromModelName = fromModel.id;
    }
  }

  // toModel 이름 추출 (null 안전 처리)
  let toModelName = 'Unknown';
  if (toModel) {
    if (toModel.name) {
      toModelName = toModel.name;
    } else if (toModel.id) {
      toModelName = toModel.id;
    }
  }

  const content = '# Handoff Context\n\n' +
    '## Transfer Information\n' +
    '- **From**: ' + fromModelName + '\n' +
    '- **To**: ' + toModelName + '\n' +
    '- **Reason**: ' + (reason || 'Rate limit reached') + '\n' +
    '- **Timestamp**: ' + timestamp + '\n\n' +
    '## Current Task\n' +
    (currentTask || 'No active task recorded') + '\n\n' +
    '## Session Summary\n' +
    (sessionSummary || 'No session summary available') + '\n\n' +
    '## Todo List\n' +
    formatTodoList(todoList) + '\n\n' +
    '## Instructions for New Orchestrator\n' +
    '1. Review the current task and session summary above\n' +
    '2. Continue from where the previous orchestrator left off\n' +
    '3. Maintain the same coding style and approach\n' +
    '4. Complete all pending todos before returning control\n\n' +
    '## Recovery Instructions\n' +
    'When Claude limit recovers below 85%, control will automatically return to Claude Opus 4.5.\n' +
    'The handoff back will include a summary of work completed.\n\n' +
    '---\n' +
    '*Generated by oh-my-claude-money fusion orchestrator*\n';

  writeFileSync(filepath, content);
  writeFileSync(latestPath, content);

  return {
    filepath: filepath,
    latestPath: latestPath,
    timestamp: timestamp
  };
}

/**
 * Todo 리스트 포맷팅
 */
function formatTodoList(todos) {
  if (!todos || !Array.isArray(todos) || todos.length === 0) {
    return 'No pending todos';
  }

  const lines = [];
  for (let i = 0; i < todos.length; i++) {
    const todo = todos[i];
    let status = '';
    if (todo.status === 'completed') {
      status = '[x]';
    } else if (todo.status === 'in_progress') {
      status = '[~]';
    } else {
      status = '[ ]';
    }
    const subject = todo.subject || todo.content || 'Unnamed task';
    lines.push('- ' + status + ' ' + subject);
  }
  return lines.join('\n');
}

/**
 * 핸드오프 컨텍스트 읽기
 */
export function readHandoffContext(cwd) {
  const handoffDir = cwd ? join(cwd, '.omcm', 'handoff') : HANDOFF_DIR;
  const latestPath = join(handoffDir, 'context.md');

  if (!existsSync(latestPath)) {
    return null;
  }

  try {
    return readFileSync(latestPath, 'utf-8');
  } catch (e) {
    return null;
  }
}

/**
 * 핸드오프 히스토리 조회
 */
export function getHandoffHistory(cwd) {
  const handoffDir = cwd ? join(cwd, '.omcm', 'handoff') : HANDOFF_DIR;

  if (!existsSync(handoffDir)) {
    return [];
  }

  try {
    const allFiles = readdirSync(handoffDir);
    const files = [];

    for (let i = 0; i < allFiles.length; i++) {
      const f = allFiles[i];
      if (f.indexOf('context-') === 0 && f.indexOf('.md') === f.length - 3) {
        const timestampStr = f.replace('context-', '').replace('.md', '');
        const timestamp = parseInt(timestampStr, 10);
        files.push({
          filename: f,
          path: join(handoffDir, f),
          timestamp: timestamp
        });
      }
    }

    // 최신순 정렬
    files.sort(function(a, b) {
      return b.timestamp - a.timestamp;
    });

    return files;
  } catch (e) {
    return [];
  }
}

export { HANDOFF_DIR };
